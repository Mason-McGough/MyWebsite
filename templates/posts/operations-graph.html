{% load static %}

<!--

* Make git repo with basic example of graph
  - client: buttons on left for selecting graphs and "run", graph on right
  - server: one route for each graph, import opnet
* Display depth of each node when run

-->

<div class="text-container">
  <img class="post-img" src="{% static 'images/blog/homepage.png' %}" alt="Operations Graph" />

  <p>If you have ever performed any data science or scientific computing, chances are your workflow went something like this:</p>

  <ol>
    <li>Load some data into a new variable</li>
    <li>Process variable through some function</li>
    <li>Pass to another function</li>
  </ol>

  <p>It's a very general workflow, particularly for anyone coming from using MATLAB or any deep learning frameworks such as Torch or TensorFlow. Writing workflows like these in code is straightforward, but for tasks with shifting demands that require workflows to constantly change, it is neither efficient nor satisfying to keep piecing together sequences of functions in code alone.</p>

  <p>Now, would it be faster to design such sequences of operations visually? Say we were to treat functions as nodes in some sort of visual "operations graph" in a graphical user interface. We could then specify an "input" to pipe data into this node. Conversely, the node would also have an "output" from which data could leave, perhaps passing to the input of another node. If you have ever created a flowchart in Visio before (or circuit design software such as MultiSim) the concept should be familiar.</p>

  <p>A graphical software to design operations graphs would allow complex workflows to be designed rapidly, flexibly, and intuitively, providing the user with a sense of exactly what is happening to their data and where. It would also demand that many details be implemented very thoroughly, and carefully. How will I make sure that this function can accept the <i>uint8</i> images coming from this other function? What if I need to pass the same variable to multiple functions and then pool their outputs somehow? Most importantly, how can I make sure that I run these operations in an order that makes sure each function runs only once it receives the input it needs from all its preceding functions?</p>

  <p>This post is concerned primarily with solving the latter problem. I put together a solution to this problem as part of a larger project at my day job. </p>

  <h2>A Graph of Operations</h2>

  <p>First, let's define a few terms. A single function is represented as a "node" in our operations graph. Each node will have zero or more "inputs" and "outputs", which correspond to the arguments and return values of the function, respectively. For instance, a node of Python's <span class="code-inline">range([start], stop[, step])</span> function would contain three possible inputs, with only the required <i>stop</i> input requiring a value.</p>

  <p>A node by itself does not mean much without its connections to other nodes. We can connect the output of one node to the input of another node by defining a "pipe" between the two. When we "run" a node, this pipe essentially passes the return value generated by the node's function from its output to the input of the next node.</p>

  <!-- ADD IMG OF TWO-NODE GRAPH WITH ONE PIPE -->
  <canvas id="graphCanvas" resize style="width: 100%; height: 300px"></canvas>

  <p>We now have the basic building blocks of an operations graph. However, there is one big practical issue that remains to be solved. How do I know the proper order in which to run these nodes? For linear graphs, we may be able to get away with running the nodes in order. For complex graphs with many branches, however, it may not be clear what this proper "order" is. Running nodes arbitrarily will be a problem, as we could be running nodes before they receive fresh inputs.

  <h2>Node Traversal</h2>

  <p>Let us treat an acyclic, unidirectional function graph like a tree with nodes and edges, where the edges represent the connection between one node's output and another node's input. Such a tree would naturally have both "root" nodes and "leaf" nodes. These root nodes are the nodes that contain inputs with no pipe. In other words, these are where the input value does not stem from the graph itself. We would therefore need to provide an input into the graph, in our case with a user interface. Likewise, the leaf nodes are where we get the outputs of our graph.</p>

  <p>With this definition in mind, we can devise a simple graph traversal scheme to walk from roots to leaves, breadth-first, and ascribe an order to each node. The following procedure will be used to assign a depth to each node:</p>

  <div class="code-block">
    <div>def get_root_nodes(self):</div>
    <div>&emsp;rootnodes = []</div>
    <div>&emsp;for node in self.nodes:</div>
    <div>&emsp;&emsp;if node.is_root():</div>
    <div>&emsp;&emsp;&emsp;rootnodes.append(node)</div>
    <div><br \></div>
    <div>&emsp;return rootnodes</div>
    <div><br \></div>
    <div>def walk_pipes(node, depth=0):</div>
    <div>&emsp;new_depth = depth</div>
    <div>&emsp;for output in node.outputs:</div>
    <div>&emsp;&emsp;if output.contains_pipe():</div>
    <div>&emsp;&emsp;&emsp;dest_node = output.node</div>
    <div>&emsp;&emsp;&emsp;new_depth = min(depth, walk_pipes(dest_node, depth + 1))</div>
    <div><br \></div>
    <div>&emsp;node.depth = new_depth</div>
    <div><br \></div>
    <div>def compute_depths():</div>
    <div>&emsp;rootnodes = get_root_nodes()</div>
    <div><br \></div>
    <div>&emsp;for rootnode in rootnodes:</div>
    <div>&emsp;&emsp;walk_pipes(rootnode)</div>
  </div>

  <h3>Set Up Graph Demo</h3>

  <p>I have prepared a project on Github to demonstrate this graph concept. Note that this demo requires that you install and launch a Flask server. If you do not already have Flask installed, I recommend creating a virtual environment first. Open a terminal and use the following instructions to get your graph running:</p>

  <h4>Clone Graph Demo</h4>

  <div class="code-block">
    <div>git clone https://github.com/JimBoonie/OpsGraph.git</div>
    <div>cd OpsGraph</div>
  </div>

  <h4>Using Conda Environment (Optional)</h4>

  <div class="code-block">
    <div>conda create -n opsgraph python=3.6</div>
    <div>source activate opsgraph</div>
  </div>

  <h4>Install Flask and Run Server</h4>

  <div class="code-block">
    <div>conda install Flask</div>
    <div>python run.py</div>
  </div>

  <p>Now, navigate to <a href="http://127.0.0.1:5000">http://127.0.0.1:5000</a> in your browser. If all is in order, it should look like the following:</p>

  <!-- IMG OF DEFAULT PAGE -->
  <img class="post-img" src="{% static 'images/blog/ops-graph-simple.png' %}" alt="Ops Graph Simple Graph" />

  <p>On the right is the graph canvas. This is where the operations graph is depicted, complete with nodes and pipes. The complete application enables you to create, connect, and modify these nodes and pipes, however this stripped-down version is good enough for demonstration.</p>

  <p>On the left is a buttons panel with two options: "Simple Graph" and "Complex Graph". You should be seeing the "Simple Graph" now. Now, on the bottom-right is a floating menu with an input field and a button that says "Run". Go ahead and click "Run". The output of the last node should be visible on the bottom-left.</p> 

  <p>If you look at the nodes, each should now display a pair of numbers. The first of these numbers indicates the node depth discussed. Recall that the depth determines the execution order of each node. The second number in the pair indicates the order in which each node was run. Try doing the same for the "Complex Graph" and take note of the relationship between the nodes and their depth and execution order. Note how every node receives inputs only from nodes with a lower depth value than itself.</p>

</div>

{% block extra_js %}
<script type="text/javascript" src="{% static 'js/paper-full.min.js' %}"></script>
<script type="text/paperscript" canvas="graphCanvas">
  var box_defaults = {
    strokeColor: 'black',
    fillColor: 'blue',
    strokeWidth: 10,
    hoverStrokeColor: 'green'
  };

  var port_defaults = {
    fillColor: 'black',
    hoverFillColor: 'green'
  };

  var line_defaults = {
    strokeColor: 'black',
    strokeWidth: 10
  };

  var text_defaults = {
    justification: 'center',
    fillColor: 'black',
    fontSize: '16px'
  };

  function assignProperties(path, properties) {
      for (key in properties) {
          path[key] = properties[key];
      }
  }

  function newBox(position, dimensions) {
    var box = new Path.Rectangle({
      point: position,
      size: dimensions,
    }); 
    assignProperties(box, box_defaults);
    box.onMouseEnter = function(event) {
        this.previousStrokeColor = this.strokeColor;
        this.strokeColor = this.hoverStrokeColor;
    };
    box.onMouseLeave = function(event) {
        this.strokeColor = this.previousStrokeColor;
    };

    return box;
  }

  function newPort(center, radius) {
    var port_path = new Path.Circle({
        center: center, 
        radius: radius
    });
    assignProperties(port_path, port_defaults);
    port_path.onMouseEnter = function(event) {
        this.previousFillColor = this.fillColor;
        this.fillColor = this.hoverFillColor;
    };
    port_path.onMouseLeave = function(event) {
        this.fillColor = this.previousFillColor;
    };

    return port_path;
  }

  function newLine(startpoint, endpoint) {
    var line = new Path.Line(startpoint, endpoint);
    assignProperties(line, line_defaults);

    return line;
  }

  function newText(position, value) {
    var text = new PointText({
      point: position,
      content: value  
    });
    assignProperties(text, text_defaults);

    return text;
  }

  var line1 = newLine([180, 150], [320, 150]);
  var box1 = newBox([80, 100], [100, 100]);
  var box2 = newBox([320, 100], [100, 100]);
  var port1 = newPort([180, 150], 20);
  var port2 = newPort([320, 150], 20);

  var box_text = newText([130, 80], "Node");
  var pipe_text = newText([250, 130], "Pipe");
  var out_text = newText([215, 180], "Output");
  var in_text = newText([285, 180], "Input");
</script>
{% endblock extra_js %}