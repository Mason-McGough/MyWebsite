<div class="text-container">
  <img class="post-img" src="{{ url_for('static', filename='images/blog/ops-graph.png') }}" alt="Operations Graph" />

  <p>If you have ever performed any data science or scientific computing, chances are your workflow went something like this:</p>

  <ol>
    <li>Load some data into a new variable</li>
    <li>Process variable through some function</li>
    <li>Pass output(s) to another function and so on...</li>
  </ol>

  <p>It's a very general workflow, particularly for anyone coming from using MATLAB or any deep learning frameworks such as Torch or TensorFlow. Writing workflows like these in code is straightforward, but for tasks with shifting demands that require frequent manual modifications and exploration, it is neither efficient nor satisfying to keep piecing together sequences of functions in code alone.</p>

  <p>Now, would it be faster to design such sequences of operations visually? Say we were to treat functions as nodes of an "operations graph," or computational graph, in a graphical user interface. We could then specify an "input" to pipe data into this node. Conversely, the node would also have an "output" from which data could leave, perhaps passing to the input of another node. The concept is similar in principle to Simulink, but if you have used software like Visio, MultiSim, or even the ShaderFX graphs in Autodesk Maya, the concept should be familiar.</p>

  <p>A graphical software to design operations graphs would allow complex workflows to be designed rapidly, flexibly, and intuitively, providing the user with a sense of exactly what is happening to their data and where. It would also demand that many details be implemented thoroughly, and carefully. How will I make sure that this function can accept the <i>uint8</i> images coming from this other function? What if I need to pass the same variable to multiple functions and then pool their outputs? Most importantly, how can I make sure that I run these operations in an order such that each function runs only once it receives the inputs it needs from all preceding functions?</p>

  <p>This post is concerned primarily with solving the latter problem. I put together a solution to this problem as part of a larger project at my day job. The solution is quite simple, but requires that we define a few terms first.</p>

  <h2>A Graph of Operations</h2>

  <p>A single function is represented as a "node" in our operations graph. Each node will have zero or more "inputs" and "outputs", which correspond to the arguments and return values of the function, respectively. For instance, a node of Python's <code>range([start], stop[, step])</code> function would contain one output and three possible inputs, with only the required <i>stop</i> input requiring a value.</p>

  <p>A node by itself does not mean much without its connections to other nodes. We can connect the output of one node to the input of another node by defining a "pipe" between the two. When we "run" a node, this pipe essentially passes the return value generated by the node's function from its output to the input of the next node.</p>

  <div style="text-align: center;">
    <canvas id="canvas-1" resize style="width: 500px; height: 300px; margin: 0 auto;"></canvas>
  </div>

  <p>We now have the basic building blocks of an operations graph. However, there is one big practical issue that remains to be solved. How do I know the proper order in which to run these nodes? For linear graphs, we may be able to get away with running the nodes in order. For complex graphs with many branches, however, it may not be clear what this proper "order" is. Running nodes arbitrarily will be a problem, as we could be running nodes before they receive fresh inputs.

  <h2>Node Traversal</h2>

  <p>Let us treat an acyclic, unidirectional computational graph like a tree with nodes and edges, where the edges represent the connection between one node's output and another node's input. Such a tree would naturally have both "root" nodes and "leaf" nodes. These root nodes are the nodes that only contain inputs with no pipe connected to them. Such nodes do not depend on any other node's output in order to execute. We users would therefore need to provide values to these inputs with something like a form. Likewise, the leaf nodes are nodes which contain unconnected outputs, i.e. no other node depends on their outputs. We might want to monitor such outputs, experimenting with different network configurations and input values to get the outputs we desire.</p>

  <p>For example, say we wanted to load an RGB image into memory, convert it to grayscale, and then make a binary mask using a simple threshold. We also want to blend the mask with the original RGB image to visualize what we thresholded. Such a workflow might have a graph that looks like this:</p>

  <div style="text-align: center;">
    <canvas id="canvas-2" resize style="width: 500px; height: 500px; margin: 0 auto;"></canvas>
  </div>

  <p>The order of execution is obvious in this example: first, we must call <code>load()</code> to load the image from <code>path</code>, then pass the loaded image to <code>rgb2gray()</code>. Next, we supply the output and <code>t</code> to <code>thresh()</code>. Lastly, we combine the outputs from <code>load()</code> and <code>thresh()</code> using <code>blend()</code>.</p>

  <p>We know we must run <code>load()</code> first because it is the only node that doesn't depend on any other nodes to run. Looking only at <code>load()</code> however, it is not clear which node to run next: <code>rgb2gray()</code> or <code>blend()</code>. Both are connected to the output of <code>load()</code>, but one depends on outputs that have not been determined yet.</p>

  <p>One solution is to walk all of the possible paths from <code>load()</code> and keep track of the "depth" of the node, or the maximum number of steps it takes to reach each node. In this case, <code>rgb2gray()</code> would have a depth of 1 whereas <code>blend()</code> a depth of 3.</p>

  <p>We can devise a simple graph traversal scheme to walk from roots to leaves, depth-first, and ascribe an order to each node. The following Python functions will assign a depth to each node using this method:</p>

  <div class="code-block">
<pre><code><strong>def get_root_nodes(nodes):</strong>
  rootnodes = []
  for node in nodes:
    if node.is_root():
      rootnodes.append(node)
      
  return rootnodes

<strong>def walk_pipes(node, depth=0):</strong>
  new_depth = depth
  for output in node.outputs:
    if output.contains_pipe():
      dest_node = output.node
      new_depth = min(depth, walk_pipes(dest_node, depth + 1))
  node.depth = new_depth
  return new_depth

<strong>def compute_depths():</strong>
  rootnodes = get_root_nodes()
  for rootnode in rootnodes:
    walk_pipes(rootnode)</code></pre>
  </div>

  <p>One thing to keep in mind with this implementation is that it does not handle loops. A simple way of fixing this is to keep track of which nodes have been visited during each recursion and stop the recursion when the same node has been traversed twice. It might also be a good idea to prevent the user from forming any loop connections on the interface side. 

  <h3>Set Up Graph Demo</h3>

  <p>I have prepared a project on Github to demonstrate this graph concept. Note that this demo requires that you install and launch a Flask server. If you do not already have Flask installed, I recommend creating a virtual environment first. Open a terminal and use the following instructions to get your graph running:</p>

  <h4>Clone Graph Demo</h4>

  <div class="code-block">
<pre><code>git clone https://github.com/JimBoonie/OpsGraph.git
cd OpsGraph</code></pre>
  </div>

  <h4>Using Conda Environment (Optional)</h4>

  <div class="code-block">
<pre><code>conda create -n opsgraph python=3.6
source activate opsgraph</code></pre>
  </div>

  <h4>Install Flask and Run Server</h4>

  <div class="code-block">
<pre><code>conda install Flask
python run.py</code></pre>
  </div>

  <p>Now, navigate to <a href="http://127.0.0.1:5000">http://127.0.0.1:5000</a> in your browser. If all is in order, it should look like the following:</p>

  <!-- IMG OF DEFAULT PAGE -->
  <img class="post-img" src="{{ url_for('static', filename='images/blog/ops-graph-simple.png') }}" alt="Ops Graph Simple Graph" />

  <p>On the right is the graph canvas. This is where the operations graph is depicted, complete with nodes and pipes. The complete application enables you to create, connect, and modify these nodes and pipes, however this heavily stripped-down version is good enough for demonstration.</p>

  <p>On the left is a buttons panel with two options: "Simple Graph" and "Complex Graph". You should be seeing the "Simple Graph" now. Now, on the bottom-right is a floating menu with an input field and a button that says "Run". Go ahead and fill in an input value, then click "Run". The output of the last node should be visible on the bottom-right.</p> 

  <p>If you look at the nodes, each should now display a pair of numbers. The first of these numbers indicates the node depth discussed. Recall that the depth determines the execution priority of each node, so a <code>depth</code> node will not be executed until all nodes with <code>depth - 1</code> run first. The second number in the pair indicates the order in which each node was run. Try doing the same for the "Complex Graph" and take note of the relationship between the nodes and their depth and execution order. Note how every node receives inputs only from nodes with a lower depth value than itself.</p>

  <p>Hopefully this illustrates the concept of a functional operations graph, or computational graph. A truly useful application for creating computational graphs would allow the user to interactively construct these graphs, store graphs for later use, export outputs, compare outputs across mutliple graphs, and more. All of these features and more are under construction in the main application on which this simple demo is based. Expect more updates here as this project continues.
</div>

{% block extra_js %}
<script type="text/javascript" src="{{ url_for('static', filename='js/paper-full.min.js') }}"></script>
<script type="text/javascript">
  var box_defaults = {
    strokeColor: 'black',
    fillColor: 'white',
    strokeWidth: 10,
    hoverStrokeColor: 'green'
  };

  var port_defaults = {
    fillColor: 'black',
    hoverFillColor: 'green'
  };

  var line_defaults = {
    strokeColor: 'black',
    strokeWidth: 10
  };

  var text_defaults = {
    justification: 'center',
    fillColor: 'black',
    fontSize: '16px'
  };

  function assignProperties(path, properties) {
      for (key in properties) {
          path[key] = properties[key];
      }
  }

  function newBox(position, dimensions) {
    var box = new paper.Path.Rectangle({
      point: position,
      size: dimensions,
    }); 
    assignProperties(box, box_defaults);
    box.onMouseEnter = function(event) {
        this.previousStrokeColor = this.strokeColor;
        this.strokeColor = this.hoverStrokeColor;
    };
    box.onMouseLeave = function(event) {
        this.strokeColor = this.previousStrokeColor;
    };

    return box;
  }

  function newPort(center, radius, output) {
    var port_path = new paper.Path.Circle({
        center: center, 
        radius: radius
    });
    assignProperties(port_path, port_defaults);
    if (output) {
      port_path.hoverFillColor = 'red';
    }
    port_path.onMouseEnter = function(event) {
        this.previousFillColor = this.fillColor;
        this.fillColor = this.hoverFillColor;
    };
    port_path.onMouseLeave = function(event) {
        this.fillColor = this.previousFillColor;
    };

    return port_path;
  }

  function newLine(startpoint, endpoint) {
    var line = new paper.Path.Line(startpoint, endpoint);
    assignProperties(line, line_defaults);

    return line;
  }

  function newText(position, value) {
    var text = new paper.PointText({
      point: position,
      content: value  
    });
    assignProperties(text, text_defaults);

    return text;
  }
</script>
<script type="text/paperscript" canvas="canvas-1">
  var line1 = newLine([180, 150], [320, 150]);
  var box1 = newBox([80, 100], [100, 100]);
  var box2 = newBox([320, 100], [100, 100]);
  var port1 = newPort([180, 150], 20, true);
  var port2 = newPort([320, 150], 20, false);

  var box_text = newText([130, 80], "Node");
  var pipe_text = newText([250, 130], "Pipe");
  var out_text = newText([215, 180], "Output");
  var in_text = newText([285, 180], "Input");
</script>
<script type="text/paperscript" canvas="canvas-2">
  var line1 = newLine([250, 120], [130, 180]);
  var line2 = newLine([130, 280], [130, 350]);
  var line3 = newLine([180, 400], [300, 400]);
  var line4 = newLine([250, 120], [300, 400]);
  var load_box = newBox([200, 20], [100, 100]);
  var rgb2gray_box = newBox([80, 180], [100, 100]);
  var thresh_box = newBox([80, 350], [100, 100]);
  var blend_box = newBox([300, 350], [100, 100]);
  var port1 = newPort([250, 120], 20, true);
  var port2 = newPort([130, 180], 20, false);
  var port3 = newPort([130, 280], 20, true);
  var port4 = newPort([130, 350], 20, false);
  var port5 = newPort([180, 400], 20, true);
  var port6 = newPort([300, 400], 20, false);
  var port6 = newPort([300, 400], 20, false);
  var port7 = newPort([200, 70], 20, false);
  var port8 = newPort([80, 400], 20, false);
  var port8 = newPort([400, 400], 20, true);

  var loadimage_input_text = newText([150, 75], "path");
  var thresh_input_text = newText([50, 405], "t");
  var loadimage_text = newText([250, 70], "load()");
  var rgb2gray_text = newText([130, 230], "rgb2gray()");
  var thresh_text = newText([130, 400], "thresh()");
  var blend_text = newText([350, 400], "blend()");
  var output_text = newText([450, 405], "output");
</script>
{% endblock extra_js %}